<!DOCTYPE html>
<html>
<head>
	<title>Word Cards</title>
	<meta http-equiv='Content-Type' content='text/html'; charset='UTF-8'>
	<meta name='viewport' content='width=device-width, initial-scale=1.0'>
	<meta name='theme-color' content='#999999'>
	<meta name='Description' content='About: Flashcard quiz thing for babby, Author:Tristan Curry, Megan Curry'>
	<link rel='manifest' href='manifest.json' />
	<link rel='stylesheet' type='text/css' href='css/styles.css'/>
</head>

<body>
	<script type='text/javascript' src='scripts/swHandling.js'></script>

	<div onclick='void(0);'>
		<div class='update'>update ready!<button id='updateBtn'>UPDATE</button></div>
	</div>

<script type="text/javascript">
const MAX_RECENT_WORDS = 6;
const PROBLEM_OPTIONS = 3;

const alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'];

const skinCodes = [
	'',
	'🏻',
	'🏼',
	'🏽',
	'🏾',
	'🏿',
];

const genderCodes = [
	'👨',
	'👩',
];

const hairCodes = [
'',
'🦰',
'🦱',
'🦳',
'🦲',
];

const wordbase = [
	{word: 'ant', syl: 1, char: '🐜'},
	{word: 'cat', syl: 1, char: '🐈'},
	{word: 'baby', syl: 2, char: '👶', skin: true},
	{word: 'cow', syl: 1, char: '🐄'},
	{word: 'bird', syl: 1, char: '🐦'},
	{word: 'crab', syl: 1, char: '🦀'},
	{word: 'bee', syl: 1, char: '🐝'},
	{word: 'apple', syl: 2, char: '🍎'},
	{word: 'banana', syl: 3, char: '🍌'},
	{word: 'car', syl: 1, char: '🚗'},
	{word: 'plane', syl: 1, char: '✈️'},
	{word: 'astronaut', syl: 3, char: '&zwj;🚀', skin: true, gender: true},
];

const filterWordbaseByLetter = (wb, letter) => {
	let matches = wb.filter(entry => entry.word[0] == letter);
	let complement = wb.filter(entry => entry.word[0] != letter);
	if(matches.length < 1) {
		const err = new Error(`No words found for letter '${letter}'`);
		throw err;
	}
	return {matches, complement};
}

const updateRecentWordbase = (recent_wb, wordInfo, max = MAX_RECENT_WORDS) => {
	if (wordInfo.word) {
		recent_wb.push(wordInfo);
		if (recent_wb.length > max) {
			recent_wb.shift();
		}
	} else {
		const err = new Error(`No word found with which to update recent words list - list not updated`);
		throw err;
	}
	return;
}

//need an object to hold onto...
//a wordbase from which problems are drawn
//a complement_wb (if any)
//a recent_wb (if any)
//DOM element for rendering into

//filter wordbase according to target letter. -store
//shuffle matches - store shallow copy of matches


const buildProblemSet = (wb, complement_wb, trackRecent = true) => {
	let problemSet = {};

	let problemWordbase = Array.from(wb);
	problemSet.wb = shuffleWordbase(problemWordbase);

	if(trackRecent == true) {
		problemSet.recent_wb = [];
	}

	problemSet.currentProblem = 0;

	problemSet.render = async function (targetElement) {
		let problemInfo = await buildProblemInfo(this.wb[this.currentProblem], complement_wb, this.recent_wb);
		if (this.recent_wb) {
			let incorrectSolutions = problemInfo.solutions.filter(wordInfo => wordInfo != this.wb[this.currentProblem]);
			incorrectSolutions.forEach(soln => updateRecentWordbase(this.recent_wb, soln));
			console.log(this.recent_wb);
		}
		let problemCard = await buildProblemCard(problemInfo);
		targetElement.appendChild(problemCard);
		this.currentProblem ++;
		if(this.currentProblem >= this.wb.length) {
			shuffleWordbase(this.wb);
			this.currentProblem = 0;
		}
		return;
	}

	return problemSet;
}




const buildProblemCard = async (problemInfo) => {
	//build the html structure of the problem card, if it doesn't already exist
	let problemCard = document.createElement('div');
		problemCard.classList.add('problem-card');

		let markup = `
			<div class="target-letter"></div>
			<div class="solutions"></div>
		`;
		problemCard.insertAdjacentHTML('beforeend', markup);

	//put the targetLetter in the right spot
	const targetLetterDiv = problemCard.getElementsByClassName('target-letter')[0];
	targetLetterDiv.textContent = problemInfo.targetLetter;

	const solutionsDiv = problemCard.getElementsByClassName('solutions')[0];
	//render the solutions
	let promises = [];
	problemInfo.solutions.forEach(entry => {
		let correct = false;
		if (entry == problemInfo.correctSolution) {correct = true;}
		promises.push(buildSolutionMarkup(entry, correct));
	});

	const results = await Promise.allSettled(promises);

	results.forEach(result => {
		if (result.status == 'fulfilled') {
			solutionsDiv.insertAdjacentHTML('beforeend', result.value);
		} else {
			const err = new Error(result.reason);
			console.error(err);
		}
	});

	return problemCard;
}

const buildProblemInfo = async (wordInfo, complement_wb, recent_wb) => {
	// get target letter from wordInfo.
	let targetLetter = '';
	if (!wordInfo.word) {
		const err = new Error(`No word exists for wordbase entry (index ${wordbase.indexOf(wordInfo)})`);
		throw err;
		return;
	} else {
		targetLetter = wordInfo.word[0];
	}
	//if no complement_wb specified, use the master wordbase less this problem's wordInfo
	if (!complement_wb) {
		let index = wordbase.indexOf(wordInfo);
		if (index > -1) {
			complement_wb = Array.from(wordbase);
			complement_wb.splice(index, 1);
		}
	}
	// get some more wordInfos from the complement_wb that aren't in the recent_wb
	let possible_wb = Array.from(complement_wb);
	console.log(possible_wb);
	if (recent_wb) {
		possible_wb = complement_wb.filter(entry => {
			if (recent_wb.indexOf(entry) > -1) {
				return false;
			} else {
				return true;
			}
		});
	}
	console.log(possible_wb);
	// shuffle the possible options for words
	possible_wb = shuffleWordbase(possible_wb);
	let numToChoose = Math.min(PROBLEM_OPTIONS - 1, possible_wb.length);

	//pick the appropriate number of options, starting at the top of possible_wb
	possible_wb = possible_wb.slice(0, numToChoose);
	possible_wb.push(wordInfo);
	let solutions = shuffleWordbase(possible_wb);

	let problemInfo = {
		targetLetter,
		solutions,
		correctSolution: wordInfo,
	}
	return problemInfo;
}


const delay = time => {
	return new Promise((resolve, reject) => {
		if(isNaN(time)) {
			reject (new Error('delay requires a valid number for time!'));
		} else {
			setTimeout(resolve, time);
		}
	});
}

const alphabetiseWordbase = wb => {
	let sorted = Array.from(wb);
		sorted.sort((wordInfo1, wordInfo2) => {
		if (wordInfo1.word[0] > wordInfo2.word[0] || (wordInfo1.word && !wordInfo2.word)) {
			return 1;
		}
		if (wordInfo1.word[0] < wordInfo2.word[0] || (!wordInfo1.word && wordInfo2.word)) {
			return -1;
		}
		return 0;
	});
	return sorted;
}



const shuffleWordbase = wb => {
	//make shallow copy of original wordbase
	let shuff = Array.from(wb);
	let currentIndex = shuff.length;
	let swapnil, randomIndex;

	while(currentIndex != 0) {
		randomIndex = Math.floor(Math.random() * currentIndex);
		currentIndex --;

		swapnil = shuff[currentIndex];
		shuff[currentIndex] = shuff[randomIndex];
		shuff[randomIndex] = swapnil;
	}
	return shuff;
}

const chooseRandomFeature = featureList => {
	let selection = Math.floor((featureList.length)*Math.random());
	return featureList[selection];
}

const modifyCharString = wordInfo => {
	let foreChar = '';
	let aftChar = '';
	if(wordInfo.gender){
		foreChar += chooseRandomFeature(genderCodes);
	}
	if(wordInfo.skin){
		if(wordInfo.gender){
			foreChar += chooseRandomFeature(skinCodes);
		} else {
			aftChar += chooseRandomFeature(skinCodes);
		}
	}
	if(wordInfo.hair){
		aftChar += `&zwj;${chooseRandomFeature(hairCodes)}`;
	}

	return (foreChar + wordInfo.char + aftChar);
}

const findWordInfo = (word, wb) => {
	return new Promise ((resolve, reject) => {
		if(word) {
		let wordInfo = wb.find(entry => entry.word.toLowerCase() == word.toLowerCase());
		if(wordInfo) {
			resolve(wordInfo);
		} else {
			const errMsg = `Word '${word}' not found in database!`;
			throw errMsg;
			reject(errMsg);
		}
	} else {
		const errMsg = 'No word was specified! Could not find wordInfo in database';
		throw errMsg;
		reject(errMsg);
	}
	});
}

const buildSolutionMarkup = (wordInfo, correct) => {
	return new Promise ((resolve, reject) => {
		if (wordInfo.char && wordInfo.word) {
			let modChar = modifyCharString(wordInfo);
			let solutionTextClassName = 'solution-text';
			if (correct === true) {solutionTextClassName += ' correct'}
			else if (correct === false) {solutionTextClassName += ' incorrect'}
			let	markup = `<div class="solution">
					<div class='solution-image'>${modChar}</div>
					<div class="${solutionTextClassName}">${wordInfo.word}</div>
				</div>`;
			resolve (markup);
		} else {
			let errMsg = 'wordInfo did not have the necessary information';
			if(!wordInfo.word) {errMsg += ': \nword was not specified!';}
			if(wordInfo.word && !wordInfo.char) {errMsg += ` for '${wordInfo.word}' \nImage was not specified!`;}
			throw errMsg;
			reject (errMsg);
		}
	});
}

const renderWordbase = async (wb, targetElement) => {
	let promises = [];
	wb.forEach(entry => {
		promises.push(buildSolutionMarkup(entry));
	});

	const results = await Promise.allSettled(promises);

	results.forEach(result => {
		if (result.status == 'fulfilled') {
			targetElement.insertAdjacentHTML('beforeend', result.value);
		} else {
			const err = new Error(result.reason);
			console.error(err);
		}
	});
}


let bases = filterWordbaseByLetter(wordbase, 'a');
console.log(bases);
let problemmo = buildProblemSet(bases.matches, bases.complement);
console.log(problemmo);
problemmo.render(document.body).then(res => problemmo.render(document.body)).catch(err => console.error(err));
;
</script>
</body>
</html>
